// Package oauth2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package oauth2

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

const (
	BasicAuthScopes   = "basicAuth.Scopes"
	BearerTokenScopes = "bearerToken.Scopes"
)

// ServerUrlProductionServer defines the Server URL for Production Server
const ServerUrlProductionServer = "https://oauth2.quran.foundation"

// ServerUrlStagingServer defines the Server URL for Staging Server
const ServerUrlStagingServer = "https://staging-oauth2.quran.foundation"

// Defines values for Oauth2AuthorizeParamsResponseType.
const (
	Code      Oauth2AuthorizeParamsResponseType = "code"
	CodeToken Oauth2AuthorizeParamsResponseType = "code token"
	IdToken   Oauth2AuthorizeParamsResponseType = "id_token"
	Token     Oauth2AuthorizeParamsResponseType = "token"
)

// Defines values for Oauth2TokenExchangeFormdataBodyGrantType.
const (
	AuthorizationCode Oauth2TokenExchangeFormdataBodyGrantType = "authorization_code"
	ClientCredentials Oauth2TokenExchangeFormdataBodyGrantType = "client_credentials"
	RefreshToken      Oauth2TokenExchangeFormdataBodyGrantType = "refresh_token"
)

// ErrorOAuth2 Error
type ErrorOAuth2 struct {
	// Error Error code
	Error *string `json:"error,omitempty"`

	// ErrorDebug Error Debug Information
	//
	// Only available in dev mode.
	ErrorDebug *string `json:"error_debug,omitempty"`

	// ErrorDescription Human-readable ASCII text providing additional information about the error
	ErrorDescription *string `json:"error_description,omitempty"`

	// ErrorHint Error Hint
	//
	// Helps the user identify the error cause.
	ErrorHint *string `json:"error_hint,omitempty"`

	// StatusCode HTTP Status Code
	StatusCode *int64 `json:"status_code,omitempty"`
}

// IntrospectedOAuth2Token Introspection contains an access token's session data as specified by
// [IETF RFC 7662](https://tools.ietf.org/html/rfc7662)
type IntrospectedOAuth2Token struct {
	// Active Active is a boolean indicator of whether or not the presented token
	// is currently active.  The specifics of a token's "active" state
	// will vary depending on the implementation of the authorization
	// server and the information it keeps about its tokens, but a "true"
	// value return for the "active" property will generally indicate
	// that a given token has been issued by this authorization server,
	// has not been revoked by the resource owner, and is within its
	// given time window of validity (e.g., after its issuance time and
	// before its expiration time).
	Active bool `json:"active"`

	// Aud Audience contains a list of the token's intended audiences.
	Aud *[]string `json:"aud,omitempty"`

	// ClientId ID is a client identifier for the OAuth 2.0 client that
	// requested this token.
	ClientId *string `json:"client_id,omitempty"`

	// Exp Expires at is an integer timestamp, measured in the number of seconds
	// since January 1 1970 UTC, indicating when this token will expire.
	Exp *int64 `json:"exp,omitempty"`

	// Ext Extra is arbitrary data set by the session.
	Ext *map[string]interface{} `json:"ext,omitempty"`

	// Iat Issued at is an integer timestamp, measured in the number of seconds
	// since January 1 1970 UTC, indicating when this token was
	// originally issued.
	Iat *int64 `json:"iat,omitempty"`

	// Iss IssuerURL is a string representing the issuer of this token
	Iss *string `json:"iss,omitempty"`

	// Nbf NotBefore is an integer timestamp, measured in the number of seconds
	// since January 1 1970 UTC, indicating when this token is not to be
	// used before.
	Nbf *int64 `json:"nbf,omitempty"`

	// ObfuscatedSubject ObfuscatedSubject is set when the subject identifier algorithm was set to "pairwise" during authorization.
	// It is the `sub` value of the ID Token that was issued.
	ObfuscatedSubject *string `json:"obfuscated_subject,omitempty"`

	// Scope Scope is a JSON string containing a space-separated list of
	// scopes associated with this token.
	Scope *string `json:"scope,omitempty"`

	// Sub Subject of the token, as defined in JWT [RFC7519].
	// Usually a machine-readable identifier of the resource owner who
	// authorized this token.
	Sub *string `json:"sub,omitempty"`

	// TokenType TokenType is the introspected token's type, typically `Bearer`.
	TokenType *string `json:"token_type,omitempty"`

	// TokenUse TokenUse is the introspected token's use, for example `access_token` or `refresh_token`.
	TokenUse *string `json:"token_use,omitempty"`

	// Username Username is a human-readable identifier for the resource owner who
	// authorized this token.
	Username *string `json:"username,omitempty"`
}

// OAuth2TokenExchange OAuth2 Token Exchange Result
type OAuth2TokenExchange struct {
	// AccessToken The access token issued by the authorization server.
	AccessToken *string `json:"access_token,omitempty"`

	// ExpiresAt The date and time when the access token expires, in ISO 8601 format
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// ExpiresIn The lifetime in seconds of the access token. For
	// example, the value "3600" denotes that the access token will
	// expire in one hour from the time the response was generated.
	ExpiresIn *int64 `json:"expires_in,omitempty"`

	// IdToken To retrieve a refresh token request the id_token scope.
	IdToken *string `json:"id_token,omitempty"`

	// RefreshToken The refresh token, which can be used to obtain new
	// access tokens. To retrieve it add the scope "offline" to your access token request.
	RefreshToken *string `json:"refresh_token,omitempty"`

	// Scope The scope of the access token
	Scope *string `json:"scope,omitempty"`

	// TokenType The type of the token issued
	TokenType *string `json:"token_type,omitempty"`
}

// OidcUserInfo OpenID Connect Userinfo
type OidcUserInfo struct {
	// Email End-User's preferred e-mail address. Its value MUST conform to the RFC 5322 [RFC5322] addr-spec syntax. The RP MUST NOT rely upon this value being unique, as discussed in Section 5.7.
	Email *string `json:"email,omitempty"`

	// FirstName Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; all can be present, with the names being separated by space characters.
	FirstName *string `json:"first_name,omitempty"`

	// LastName Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; all can be present, with the names being separated by space characters.
	LastName *string `json:"last_name,omitempty"`
}

// Oauth2AuthorizeParams defines parameters for Oauth2Authorize.
type Oauth2AuthorizeParams struct {
	// ResponseType The type of response expected from the OAuth2 server
	ResponseType Oauth2AuthorizeParamsResponseType `form:"response_type" json:"response_type"`

	// ClientId The client id that you already created
	ClientId string `form:"client_id" json:"client_id"`

	// RedirectUri Where to redirect after the oauth2 process completed
	RedirectUri string `form:"redirect_uri" json:"redirect_uri"`

	// Scope The scopes that you want to request, separated by spaces
	Scope string `form:"scope" json:"scope"`

	// State An opaque value used by the client to maintain state between the request and callback. The authorization server includes this value when redirecting the user-agent back to the client.
	State *string `form:"state,omitempty" json:"state,omitempty"`
}

// Oauth2AuthorizeParamsResponseType defines parameters for Oauth2Authorize.
type Oauth2AuthorizeParamsResponseType string

// IntrospectOauth2TokenFormdataBody defines parameters for IntrospectOauth2Token.
type IntrospectOauth2TokenFormdataBody struct {
	// Scope An optional, space separated list of required scopes. If the access token was not granted one of the
	// scopes, the result of active will be false.
	Scope *string `form:"scope,omitempty" json:"scope,omitempty"`

	// Token The string value of the token. For access tokens, this
	// is the "access_token" value returned from the token endpoint
	// defined in OAuth 2.0. For refresh tokens, this is the "refresh_token"
	// value returned.
	Token string `form:"token" json:"token"`
}

// Oauth2TokenExchangeFormdataBody defines parameters for Oauth2TokenExchange.
type Oauth2TokenExchangeFormdataBody struct {
	// ClientId The client identifier issued to the client during the registration process
	ClientId *string `form:"client_id,omitempty" json:"client_id,omitempty"`

	// Code The authorization code received from the authorization server
	Code *string `form:"code,omitempty" json:"code,omitempty"`

	// GrantType The grant type of the token request
	GrantType Oauth2TokenExchangeFormdataBodyGrantType `form:"grant_type" json:"grant_type"`

	// RedirectUri The redirect URI used in the initial authorization request
	RedirectUri *string `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty"`

	// RefreshToken The refresh token issued to the client
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty"`

	// Scope The scope of the access request
	Scope *string `form:"scope,omitempty" json:"scope,omitempty"`
}

// Oauth2TokenExchangeFormdataBodyGrantType defines parameters for Oauth2TokenExchange.
type Oauth2TokenExchangeFormdataBodyGrantType string

// IntrospectOauth2TokenFormdataRequestBody defines body for IntrospectOauth2Token for application/x-www-form-urlencoded ContentType.
type IntrospectOauth2TokenFormdataRequestBody IntrospectOauth2TokenFormdataBody

// Oauth2TokenExchangeFormdataRequestBody defines body for Oauth2TokenExchange for application/x-www-form-urlencoded ContentType.
type Oauth2TokenExchangeFormdataRequestBody Oauth2TokenExchangeFormdataBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Oauth2Authorize request
	Oauth2Authorize(ctx context.Context, params *Oauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IntrospectOauth2TokenWithBody request with any body
	IntrospectOauth2TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IntrospectOauth2TokenWithFormdataBody(ctx context.Context, body IntrospectOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeOidcSession request
	RevokeOidcSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Oauth2TokenExchangeWithBody request with any body
	Oauth2TokenExchangeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Oauth2TokenExchangeWithFormdataBody(ctx context.Context, body Oauth2TokenExchangeFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOidcUserInfo request
	GetOidcUserInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Oauth2Authorize(ctx context.Context, params *Oauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2AuthorizeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IntrospectOauth2TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIntrospectOauth2TokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IntrospectOauth2TokenWithFormdataBody(ctx context.Context, body IntrospectOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIntrospectOauth2TokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeOidcSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeOidcSessionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2TokenExchangeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2TokenExchangeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Oauth2TokenExchangeWithFormdataBody(ctx context.Context, body Oauth2TokenExchangeFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauth2TokenExchangeRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOidcUserInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOidcUserInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewOauth2AuthorizeRequest generates requests for Oauth2Authorize
func NewOauth2AuthorizeRequest(server string, params *Oauth2AuthorizeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth2/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, params.Scope); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIntrospectOauth2TokenRequestWithFormdataBody calls the generic IntrospectOauth2Token builder with application/x-www-form-urlencoded body
func NewIntrospectOauth2TokenRequestWithFormdataBody(server string, body IntrospectOauth2TokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewIntrospectOauth2TokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewIntrospectOauth2TokenRequestWithBody generates requests for IntrospectOauth2Token with any type of body
func NewIntrospectOauth2TokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth2/introspect")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevokeOidcSessionRequest generates requests for RevokeOidcSession
func NewRevokeOidcSessionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth2/sessions/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauth2TokenExchangeRequestWithFormdataBody calls the generic Oauth2TokenExchange builder with application/x-www-form-urlencoded body
func NewOauth2TokenExchangeRequestWithFormdataBody(server string, body Oauth2TokenExchangeFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewOauth2TokenExchangeRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewOauth2TokenExchangeRequestWithBody generates requests for Oauth2TokenExchange with any type of body
func NewOauth2TokenExchangeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth2/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOidcUserInfoRequest generates requests for GetOidcUserInfo
func NewGetOidcUserInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/userinfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// Oauth2AuthorizeWithResponse request
	Oauth2AuthorizeWithResponse(ctx context.Context, params *Oauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeResponse, error)

	// IntrospectOauth2TokenWithBodyWithResponse request with any body
	IntrospectOauth2TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IntrospectOauth2TokenResponse, error)

	IntrospectOauth2TokenWithFormdataBodyWithResponse(ctx context.Context, body IntrospectOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*IntrospectOauth2TokenResponse, error)

	// RevokeOidcSessionWithResponse request
	RevokeOidcSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RevokeOidcSessionResponse, error)

	// Oauth2TokenExchangeWithBodyWithResponse request with any body
	Oauth2TokenExchangeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Oauth2TokenExchangeResponse, error)

	Oauth2TokenExchangeWithFormdataBodyWithResponse(ctx context.Context, body Oauth2TokenExchangeFormdataRequestBody, reqEditors ...RequestEditorFn) (*Oauth2TokenExchangeResponse, error)

	// GetOidcUserInfoWithResponse request
	GetOidcUserInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOidcUserInfoResponse, error)
}

type Oauth2AuthorizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorOAuth2
}

// Status returns HTTPResponse.Status
func (r Oauth2AuthorizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2AuthorizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IntrospectOauth2TokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntrospectedOAuth2Token
	JSON400      *ErrorOAuth2
	JSON401      *ErrorOAuth2
}

// Status returns HTTPResponse.Status
func (r IntrospectOauth2TokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IntrospectOauth2TokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeOidcSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RevokeOidcSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeOidcSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type Oauth2TokenExchangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuth2TokenExchange
	JSON400      *ErrorOAuth2
	JSON401      *ErrorOAuth2
}

// Status returns HTTPResponse.Status
func (r Oauth2TokenExchangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r Oauth2TokenExchangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOidcUserInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OidcUserInfo
	JSON401      *ErrorOAuth2
}

// Status returns HTTPResponse.Status
func (r GetOidcUserInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOidcUserInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// Oauth2AuthorizeWithResponse request returning *Oauth2AuthorizeResponse
func (c *ClientWithResponses) Oauth2AuthorizeWithResponse(ctx context.Context, params *Oauth2AuthorizeParams, reqEditors ...RequestEditorFn) (*Oauth2AuthorizeResponse, error) {
	rsp, err := c.Oauth2Authorize(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2AuthorizeResponse(rsp)
}

// IntrospectOauth2TokenWithBodyWithResponse request with arbitrary body returning *IntrospectOauth2TokenResponse
func (c *ClientWithResponses) IntrospectOauth2TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IntrospectOauth2TokenResponse, error) {
	rsp, err := c.IntrospectOauth2TokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIntrospectOauth2TokenResponse(rsp)
}

func (c *ClientWithResponses) IntrospectOauth2TokenWithFormdataBodyWithResponse(ctx context.Context, body IntrospectOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*IntrospectOauth2TokenResponse, error) {
	rsp, err := c.IntrospectOauth2TokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIntrospectOauth2TokenResponse(rsp)
}

// RevokeOidcSessionWithResponse request returning *RevokeOidcSessionResponse
func (c *ClientWithResponses) RevokeOidcSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RevokeOidcSessionResponse, error) {
	rsp, err := c.RevokeOidcSession(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeOidcSessionResponse(rsp)
}

// Oauth2TokenExchangeWithBodyWithResponse request with arbitrary body returning *Oauth2TokenExchangeResponse
func (c *ClientWithResponses) Oauth2TokenExchangeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*Oauth2TokenExchangeResponse, error) {
	rsp, err := c.Oauth2TokenExchangeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2TokenExchangeResponse(rsp)
}

func (c *ClientWithResponses) Oauth2TokenExchangeWithFormdataBodyWithResponse(ctx context.Context, body Oauth2TokenExchangeFormdataRequestBody, reqEditors ...RequestEditorFn) (*Oauth2TokenExchangeResponse, error) {
	rsp, err := c.Oauth2TokenExchangeWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauth2TokenExchangeResponse(rsp)
}

// GetOidcUserInfoWithResponse request returning *GetOidcUserInfoResponse
func (c *ClientWithResponses) GetOidcUserInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOidcUserInfoResponse, error) {
	rsp, err := c.GetOidcUserInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOidcUserInfoResponse(rsp)
}

// ParseOauth2AuthorizeResponse parses an HTTP response from a Oauth2AuthorizeWithResponse call
func ParseOauth2AuthorizeResponse(rsp *http.Response) (*Oauth2AuthorizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2AuthorizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorOAuth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseIntrospectOauth2TokenResponse parses an HTTP response from a IntrospectOauth2TokenWithResponse call
func ParseIntrospectOauth2TokenResponse(rsp *http.Response) (*IntrospectOauth2TokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IntrospectOauth2TokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntrospectedOAuth2Token
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorOAuth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorOAuth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRevokeOidcSessionResponse parses an HTTP response from a RevokeOidcSessionWithResponse call
func ParseRevokeOidcSessionResponse(rsp *http.Response) (*RevokeOidcSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeOidcSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOauth2TokenExchangeResponse parses an HTTP response from a Oauth2TokenExchangeWithResponse call
func ParseOauth2TokenExchangeResponse(rsp *http.Response) (*Oauth2TokenExchangeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &Oauth2TokenExchangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuth2TokenExchange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorOAuth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorOAuth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetOidcUserInfoResponse parses an HTTP response from a GetOidcUserInfoWithResponse call
func ParseGetOidcUserInfoResponse(rsp *http.Response) (*GetOidcUserInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOidcUserInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OidcUserInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorOAuth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"nPyU4Lcf/zcAAP//vCAVERxGAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
